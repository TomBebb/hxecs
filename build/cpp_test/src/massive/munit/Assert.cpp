// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_ValueType
#include <ValueType.h>
#endif
#ifndef INCLUDED_massive_haxe_Exception
#include <massive/haxe/Exception.h>
#endif
#ifndef INCLUDED_massive_munit_Assert
#include <massive/munit/Assert.h>
#endif
#ifndef INCLUDED_massive_munit_AssertionException
#include <massive/munit/AssertionException.h>
#endif
#ifndef INCLUDED_massive_munit_MUnitException
#include <massive/munit/MUnitException.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_55_isTrue,"massive.munit.Assert","isTrue",0x34cf1719,"massive.munit.Assert.isTrue","massive/munit/Assert.hx",55,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_70_isFalse,"massive.munit.Assert","isFalse",0xe5859778,"massive.munit.Assert.isFalse","massive/munit/Assert.hx",70,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_85_isNull,"massive.munit.Assert","isNull",0x30da0e52,"massive.munit.Assert.isNull","massive/munit/Assert.hx",85,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_100_isNotNull,"massive.munit.Assert","isNotNull",0xec2b6a4f,"massive.munit.Assert.isNotNull","massive/munit/Assert.hx",100,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_115_isNaN,"massive.munit.Assert","isNaN",0x97c09f50,"massive.munit.Assert.isNaN","massive/munit/Assert.hx",115,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_130_isNotNaN,"massive.munit.Assert","isNotNaN",0x370391f3,"massive.munit.Assert.isNotNaN","massive/munit/Assert.hx",130,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_145_isType,"massive.munit.Assert","isType",0x34d46285,"massive.munit.Assert.isType","massive/munit/Assert.hx",145,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_160_isNotType,"massive.munit.Assert","isNotType",0xf025be82,"massive.munit.Assert.isNotType","massive/munit/Assert.hx",160,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_178_areEqual,"massive.munit.Assert","areEqual",0x455d6dc1,"massive.munit.Assert.areEqual","massive/munit/Assert.hx",178,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_196_areNotEqual,"massive.munit.Assert","areNotEqual",0x6c4589b4,"massive.munit.Assert.areNotEqual","massive/munit/Assert.hx",196,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_212_areSame,"massive.munit.Assert","areSame",0x02a125f9,"massive.munit.Assert.areSame","massive/munit/Assert.hx",212,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_228_areNotSame,"massive.munit.Assert","areNotSame",0x76c00966,"massive.munit.Assert.areNotSame","massive/munit/Assert.hx",228,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_245_doesMatch,"massive.munit.Assert","doesMatch",0xd67355ab,"massive.munit.Assert.doesMatch","massive/munit/Assert.hx",245,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_262_doesNotMatch,"massive.munit.Assert","doesNotMatch",0xe3dd528c,"massive.munit.Assert.doesNotMatch","massive/munit/Assert.hx",262,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_278_throws,"massive.munit.Assert","throws",0x5925cf4e,"massive.munit.Assert.throws","massive/munit/Assert.hx",278,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_300_fail,"massive.munit.Assert","fail",0x65f6825f,"massive.munit.Assert.fail","massive/munit/Assert.hx",300,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_303_equals,"massive.munit.Assert","equals",0x8a579900,"massive.munit.Assert.equals","massive/munit/Assert.hx",303,0xdba0f24f)
HX_LOCAL_STACK_FRAME(_hx_pos_e85334962c7a1909_45_boot,"massive.munit.Assert","boot",0x635c4cb3,"massive.munit.Assert.boot","massive/munit/Assert.hx",45,0xdba0f24f)
namespace massive{
namespace munit{

void Assert_obj::__construct() { }

Dynamic Assert_obj::__CreateEmpty() { return new Assert_obj; }

void *Assert_obj::_hx_vtable = 0;

Dynamic Assert_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Assert_obj > _hx_result = new Assert_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Assert_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0db0e9d7;
}

int Assert_obj::assertionCount;

void Assert_obj::isTrue(bool value,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_55_isTrue)
HXLINE(  56)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  57)		if (value) {
HXLINE(  57)			return;
            		}
HXLINE(  58)		if (hx::IsNull( message )) {
HXLINE(  58)			message = ((HX_("Expected TRUE but was [",bb,60,fc,33) + ::Std_obj::string(value)) + HX_("]",5d,00,00,00));
            		}
HXLINE(  59)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isTrue,(void))

void Assert_obj::isFalse(bool value,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_70_isFalse)
HXLINE(  71)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  72)		if (!(value)) {
HXLINE(  72)			return;
            		}
HXLINE(  73)		if (hx::IsNull( message )) {
HXLINE(  73)			message = ((HX_("Expected FALSE but was [",20,19,a9,73) + ::Std_obj::string(value)) + HX_("]",5d,00,00,00));
            		}
HXLINE(  74)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isFalse,(void))

void Assert_obj::isNull( ::Dynamic value,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_85_isNull)
HXLINE(  86)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  87)		if (hx::IsNull( value )) {
HXLINE(  87)			return;
            		}
HXLINE(  88)		if (hx::IsNull( message )) {
HXLINE(  88)			message = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(value)) + HX_("] was not NULL",2e,e4,6d,32));
            		}
HXLINE(  89)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isNull,(void))

void Assert_obj::isNotNull( ::Dynamic value,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_100_isNotNull)
HXLINE( 101)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 102)		if (hx::IsNotNull( value )) {
HXLINE( 102)			return;
            		}
HXLINE( 103)		if (hx::IsNull( message )) {
HXLINE( 103)			message = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(value)) + HX_("] was NULL",01,2d,fc,2c));
            		}
HXLINE( 104)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isNotNull,(void))

void Assert_obj::isNaN(Float value,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_115_isNaN)
HXLINE( 116)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 117)		if (::Math_obj::isNaN(value)) {
HXLINE( 117)			return;
            		}
HXLINE( 118)		if (hx::IsNull( message )) {
HXLINE( 118)			message = ((HX_("Value [",cc,41,bd,3d) + value) + HX_("]  was not NaN",9a,1a,04,75));
            		}
HXLINE( 119)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isNaN,(void))

void Assert_obj::isNotNaN(Float value,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_130_isNotNaN)
HXLINE( 131)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 132)		if (!(::Math_obj::isNaN(value))) {
HXLINE( 132)			return;
            		}
HXLINE( 133)		if (hx::IsNull( message )) {
HXLINE( 133)			message = ((HX_("Value [",cc,41,bd,3d) + value) + HX_("] was NaN",61,ab,90,31));
            		}
HXLINE( 134)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isNotNaN,(void))

void Assert_obj::isType( ::Dynamic value, ::Dynamic type,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_145_isType)
HXLINE( 146)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 147)		if (::Std_obj::is(value,type)) {
HXLINE( 147)			return;
            		}
HXLINE( 148)		if (hx::IsNull( message )) {
HXLINE( 148)			::String message1 = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(value)) + HX_("] was not of type: ",c2,44,01,71));
HXDLIN( 148)			message = (message1 + ::Type_obj::getClassName(type));
            		}
HXLINE( 149)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,isType,(void))

void Assert_obj::isNotType( ::Dynamic value, ::Dynamic type,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_160_isNotType)
HXLINE( 161)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 162)		if (!(::Std_obj::is(value,type))) {
HXLINE( 162)			return;
            		}
HXLINE( 163)		if (hx::IsNull( message )) {
HXLINE( 163)			::String message1 = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(value)) + HX_("] was of type: ",0f,1f,fb,82));
HXDLIN( 163)			message = (message1 + ::Type_obj::getClassName(type));
            		}
HXLINE( 164)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,isNotType,(void))

void Assert_obj::areEqual( ::Dynamic expected, ::Dynamic actual,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_178_areEqual)
HXLINE( 179)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 180)		bool _hx_tmp;
HXDLIN( 180)		 ::ValueType _g = ::Type_obj::_hx_typeof(expected);
HXDLIN( 180)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)5: {
HXLINE( 180)				_hx_tmp = ::Reflect_obj::compareMethods(expected,actual);
            			}
            			break;
            			case (int)7: {
HXLINE( 180)				_hx_tmp = ::Type_obj::enumEq(expected,actual);
            			}
            			break;
            			default:{
HXLINE( 180)				_hx_tmp = hx::IsEq( expected,actual );
            			}
            		}
HXDLIN( 180)		if (_hx_tmp) {
HXLINE( 180)			return;
            		}
HXLINE( 181)		if (hx::IsNull( message )) {
HXLINE( 181)			::String message1 = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(actual)) + HX_("] was not equal to expected value [",16,a1,2f,2d));
HXDLIN( 181)			message = ((message1 + ::Std_obj::string(expected)) + HX_("]",5d,00,00,00));
            		}
HXLINE( 182)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,areEqual,(void))

void Assert_obj::areNotEqual( ::Dynamic expected, ::Dynamic actual,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_196_areNotEqual)
HXLINE( 197)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 198)		 ::ValueType _g = ::Type_obj::_hx_typeof(expected);
HXDLIN( 198)		bool _hx_tmp;
HXDLIN( 198)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)5: {
HXLINE( 198)				_hx_tmp = ::Reflect_obj::compareMethods(expected,actual);
            			}
            			break;
            			case (int)7: {
HXLINE( 198)				_hx_tmp = ::Type_obj::enumEq(expected,actual);
            			}
            			break;
            			default:{
HXLINE( 198)				_hx_tmp = hx::IsEq( expected,actual );
            			}
            		}
HXDLIN( 198)		if (!(_hx_tmp)) {
HXLINE( 198)			return;
            		}
HXLINE( 199)		if (hx::IsNull( message )) {
HXLINE( 199)			::String message1 = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(actual)) + HX_("] was equal to value [",ad,d8,e6,f1));
HXDLIN( 199)			message = ((message1 + ::Std_obj::string(expected)) + HX_("]",5d,00,00,00));
            		}
HXLINE( 200)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,areNotEqual,(void))

void Assert_obj::areSame( ::Dynamic expected, ::Dynamic actual,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_212_areSame)
HXLINE( 213)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 214)		if (hx::IsEq( expected,actual )) {
HXLINE( 214)			return;
            		}
HXLINE( 215)		if (hx::IsNull( message )) {
HXLINE( 215)			::String message1 = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(actual)) + HX_("] was not the same as expected value [",ae,5f,06,10));
HXDLIN( 215)			message = ((message1 + ::Std_obj::string(expected)) + HX_("]",5d,00,00,00));
            		}
HXLINE( 216)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,areSame,(void))

void Assert_obj::areNotSame( ::Dynamic expected, ::Dynamic actual,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_228_areNotSame)
HXLINE( 229)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 230)		if (hx::IsNotEq( expected,actual )) {
HXLINE( 230)			return;
            		}
HXLINE( 231)		if (hx::IsNull( message )) {
HXLINE( 231)			::String message1 = ((HX_("Value [",cc,41,bd,3d) + ::Std_obj::string(actual)) + HX_("] was the same as expected value [",81,49,22,3e));
HXDLIN( 231)			message = ((message1 + ::Std_obj::string(expected)) + HX_("]",5d,00,00,00));
            		}
HXLINE( 232)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,areNotSame,(void))

void Assert_obj::doesMatch(::String string, ::EReg regexp,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_245_doesMatch)
HXLINE( 246)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 247)		if (regexp->match(string)) {
HXLINE( 247)			return;
            		}
HXLINE( 248)		if (hx::IsNull( message )) {
HXLINE( 248)			message = ((((HX_("Value [",cc,41,bd,3d) + string) + HX_("] was expected to match [",89,0c,56,4e)) + ::Std_obj::string(regexp)) + HX_("]",5d,00,00,00));
            		}
HXLINE( 249)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,doesMatch,(void))

void Assert_obj::doesNotMatch(::String string, ::EReg regexp,::String message, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_262_doesNotMatch)
HXLINE( 263)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 264)		if (!(regexp->match(string))) {
HXLINE( 264)			return;
            		}
HXLINE( 265)		if (hx::IsNull( message )) {
HXLINE( 265)			::String message1 = ((((HX_("Value [",cc,41,bd,3d) + string) + HX_("] was expected to not match [",fc,0c,d0,62)) + ::Std_obj::string(regexp)) + HX_("], and matched at [",a4,11,db,73));
HXDLIN( 265)			message = ((message1 + ( (int)(regexp->matchedPos()->__Field(HX_("pos",94,5d,55,00),hx::paccDynamic)) )) + HX_("]",5d,00,00,00));
            		}
HXLINE( 266)		::massive::munit::Assert_obj::fail(message,info);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Assert_obj,doesNotMatch,(void))

 ::Dynamic Assert_obj::throws( ::Dynamic expectedType, ::Dynamic code, ::Dynamic info){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_278_throws)
HXLINE( 279)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 281)			code();
HXLINE( 282)			::massive::munit::Assert_obj::fail(HX_("Expected exception wasn't thrown!",84,dc,43,8f),info);
            		}
            		catch( ::Dynamic _hx_e){
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic e = _hx_e;
HXLINE( 286)				if (::Std_obj::is(e,expectedType)) {
HXLINE( 286)					return e;
            				}
HXLINE( 287)				::String _hx_tmp = ((HX_("Expected exception of type ",d6,72,0c,f7) + ::Type_obj::getClassName(expectedType)) + HX_(" but got ",b3,1a,6e,57));
HXDLIN( 287)				::String _hx_tmp1 = ((_hx_tmp + ::Type_obj::getClassName(::Type_obj::getClass(e))) + HX_(": ",a6,32,00,00));
HXDLIN( 287)				::String _hx_tmp2 = (_hx_tmp1 + ::Std_obj::string(e));
HXDLIN( 287)				::massive::munit::Assert_obj::fail(_hx_tmp2,hx::SourceInfo(HX_("Assert.hx",98,db,a2,41),287,HX_("massive.munit.Assert",8d,67,6a,3c),HX_("throws",8d,24,c1,8e)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 289)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,throws,return )

void Assert_obj::fail(::String message, ::Dynamic info){
            	HX_GC_STACKFRAME(&_hx_pos_e85334962c7a1909_300_fail)
HXDLIN( 300)		HX_STACK_DO_THROW( ::massive::munit::AssertionException_obj::__alloc( HX_CTX ,message,info));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,fail,(void))

bool Assert_obj::equals( ::Dynamic a, ::Dynamic b){
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_303_equals)
HXDLIN( 303)		 ::ValueType _g = ::Type_obj::_hx_typeof(a);
HXDLIN( 303)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)5: {
HXLINE( 305)				return ::Reflect_obj::compareMethods(a,b);
            			}
            			break;
            			case (int)7: {
HXLINE( 304)				return ::Type_obj::enumEq(a,b);
            			}
            			break;
            			default:{
HXLINE( 314)				return hx::IsEq( a,b );
            			}
            		}
HXLINE( 303)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,equals,return )


Assert_obj::Assert_obj()
{
}

bool Assert_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"fail") ) { outValue = fail_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"isNaN") ) { outValue = isNaN_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"isTrue") ) { outValue = isTrue_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isNull") ) { outValue = isNull_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isType") ) { outValue = isType_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"throws") ) { outValue = throws_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"equals") ) { outValue = equals_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isFalse") ) { outValue = isFalse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"areSame") ) { outValue = areSame_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isNotNaN") ) { outValue = isNotNaN_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"areEqual") ) { outValue = areEqual_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isNotNull") ) { outValue = isNotNull_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isNotType") ) { outValue = isNotType_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"doesMatch") ) { outValue = doesMatch_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"areNotSame") ) { outValue = areNotSame_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"areNotEqual") ) { outValue = areNotEqual_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"doesNotMatch") ) { outValue = doesNotMatch_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"assertionCount") ) { outValue = ( assertionCount ); return true; }
	}
	return false;
}

bool Assert_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"assertionCount") ) { assertionCount=ioValue.Cast< int >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Assert_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Assert_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Assert_obj::assertionCount,HX_HCSTRING("assertionCount","\xad","\x2e","\xc2","\x06")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Assert_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Assert_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Assert_obj::assertionCount,"assertionCount");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Assert_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Assert_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Assert_obj::assertionCount,"assertionCount");
};

#endif

hx::Class Assert_obj::__mClass;

static ::String Assert_obj_sStaticFields[] = {
	HX_HCSTRING("assertionCount","\xad","\x2e","\xc2","\x06"),
	HX_HCSTRING("isTrue","\x58","\x6c","\x6a","\x6a"),
	HX_HCSTRING("isFalse","\x59","\xd9","\xd4","\x97"),
	HX_HCSTRING("isNull","\x91","\x63","\x75","\x66"),
	HX_HCSTRING("isNotNull","\x70","\xa6","\x37","\x42"),
	HX_HCSTRING("isNaN","\xf1","\xf6","\x51","\xc1"),
	HX_HCSTRING("isNotNaN","\xf2","\xf4","\x0d","\x8a"),
	HX_HCSTRING("isType","\xc4","\xb7","\x6f","\x6a"),
	HX_HCSTRING("isNotType","\xa3","\xfa","\x31","\x46"),
	HX_HCSTRING("areEqual","\xc0","\xd0","\x67","\x98"),
	HX_HCSTRING("areNotEqual","\x15","\xd0","\xf1","\x8a"),
	HX_HCSTRING("areSame","\xda","\x67","\xf0","\xb4"),
	HX_HCSTRING("areNotSame","\x25","\x6a","\x68","\x6b"),
	HX_HCSTRING("doesMatch","\xcc","\x91","\x7f","\x2c"),
	HX_HCSTRING("doesNotMatch","\x0b","\xa1","\xee","\x9b"),
	HX_HCSTRING("throws","\x8d","\x24","\xc1","\x8e"),
	HX_HCSTRING("fail","\xde","\xb9","\xb5","\x43"),
	HX_HCSTRING("equals","\x3f","\xee","\xf2","\xbf"),
	::String(null())
};

void Assert_obj::__register()
{
	hx::Object *dummy = new Assert_obj;
	Assert_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("massive.munit.Assert","\x8d","\x67","\x6a","\x3c");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Assert_obj::__GetStatic;
	__mClass->mSetStaticField = &Assert_obj::__SetStatic;
	__mClass->mMarkFunc = Assert_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Assert_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Assert_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Assert_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Assert_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Assert_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Assert_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_e85334962c7a1909_45_boot)
HXDLIN(  45)		assertionCount = (int)0;
            	}
}

} // end namespace massive
} // end namespace munit
